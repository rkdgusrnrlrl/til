# 간단한 서버 만들기 및 테스트 후기

최근 spark 라는 경량 웹프레임워크를 사용해 API 개발을 하고 있는데, 정말 경량이여서 아무것도 없어 스스로 하나씩 만들어 보고 있다. 파트 별로 나눠 후기를 작성 해본다.

## JSON to Object 또는 그 반대

request body 로 json 을 받는데, 이떄 string 값이여서 이걸 특정 Class 에 바인딩을 시켜줘야 하는데, 이게 미묘하다. 특정 Class보다 json 에 필드가 부족한 경우 인스턴스가 떨어지는데, json 에 있는 필드가 클레스에 없다면 `UnrecognizedPropertyException` 가 던져진다. 물론 해결할 수 있는 옵션이 있어보여서 해결이 가능 하지만, 이런 맵핑 류의 문제는 자장한 문제가 많다. 깊이가 깊어지면 바인딩 받는 클래스가 복잡해져서 2뎁스 정도가 좋을 것 같다.

다행히도 json String 을 맵핑 하는 것 이외에서 JsonNode 를 특정 클래스로 컨버트 할 수도 있어서, 깊이가 깊은 경우 필요한 부분까지 JsonNode 로 타고가서 맵핑한 JsonNode 에서 맵핑 하는 것도 좋은 방법 인것 같다.

### 예제

- 아래와 같은 json 에서 data 부분만 맵핑 할 생각이다.

```json
{
    "data" : {
        "userList" : [
            { "name" : "강현구", "age" : 10 },
            { "name" : "강현구", "age" : 11 }
        ]
    }
}
```

- 맵핑 반는 클래스는 아래와 깉다.

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserListData {
    private List<User> userList;
}
```

- 위의 annotation 은 `lombok` 을 사용하였다.

```java
ObjectMapper objectMapper = new ObjectMapper();
JsonNode rootNode = objectMapper.readTree(jsonReponse);
JsonNode dataNode = rootNode.path("data");
UserListData data = objectMapper.convertValue(dataNode, UserListData.class);
```

- ## 이런 식으로 중간 노드를 맵핑 받을 수 있다.

- `List<User>`  으로 바로 맵핑하고 싶었으나, `Class<List<User>>` 이런 형태가 안된다.

## 테스트

한가지 느낀 거는 API 테스트는 제약 사항이 너무 많다. 그나마 로컬에서 돌리는 테스트 내부적으로 Repository 를 초기화 할 수 있어 테스트를 격리화 할 수 있었지만 원격 환경에서는.... 또 API 테스트 시 테스트 시작시 서버를 띄우고 종료시 서버를 내리는데, 이게 비동적으로 돌아서, 여러 API 를 돌리는 경우 두번쨰 API 테스트는 다 깨진다. 이것은 방법은 더 연구 해봐야 하겠다. spark 는 내부적으로 Jetty 임베디드 서버를 썼는데, 해당 서버는 경량 서버라 서버 시작이 빠르다고 한다. 그래서 그런지 테스트 돌리는데 시간을 많이 잡아먹지 않아서 좋았다. 스프링 테스트 떄마다. 테스트 시간 떄문에 스트레스 받았는데 이점은 확실히 좋은 것 같다.

그래서 Unit 테스트가 중요하다는 것을 깨달았다. API 는 좀 러프 해질 수 밖에 없고, Unit 테스트에 다양하게 테스트 하는 것이 좋았던 것 같다. 또 Junit 은 테스트 순서가 보장 되지 않는데, 이점이 매우 좋았다. Node.js 로 개발할때 mocha 를 썼었는데, 테스트 작성 순서로 테스트가 돌아 순서가 변경되도 테스트가 깨지는 경우 검증이 어렵다. 불가능 하지야 않지만...

Junit 5 를 처음 사용 해봤는데, exception 의 경우 전에는 `@Rules` 를 사용해서 해결하고 있었는데, 이게 사라지고 `assertThrow()` 메서드가 생겨 이걸 사용하고 있다. 명시적이여서 좋긴 한데, `callback` 느낌이 나서 별로 좋지 않았다. 5로 바꾸게 된 이유는 테스트 클래스 내부에 테스트 클래스를 넣을 수 있어 테스트 scope 을 줄 수 있다. 

예를 들어 이런 것이다. 사용자 API 를 테스트 해야 하는데, 목록 간단한 테스트 는 사용자 등록이 필요 없고, 초기 사용자 등록도 미리 사용자가 등록되지 않아도 상관 없다. 하지만 사용자 삭제 및 특정 사용자 정보 가져 오는 API 를 호출 하는 경우 사용자 등록이 전제 되어있어야 한다. 이로 인해 테스트 클래스를 분리 해야 하는데,, 같은 API 테스트 인데 이런 문제 때문에 클래스가 나눠지는 단점이 있는데 5 에서는 `@Nested` 내부 클래스를 만들어 해결 할 수 있다.

최근 given when then 을 명시화 할 수 있는 방법이 없을까 하다 [spock](http://spockframework.org/) 가 괜찮아보인다. 아마 이걸로 추가 마이그레션 작업이....



## Spark

경량이라 직접 다 만들어야 한다. json 맵핑도 직접 구현 해야 되고, DI 툴도 없어 테스트, 운영에 맞게 Repository 같은 거는 Inject 해 주어야 하는데, 관련 라이브러리를 찾야야 할 것 같다. 당장은 필요 하진 않지만...

우선 다양한 웹프레임워크를 사용해 봤는데 그러다 보니 해당 프레임워크 기능을 직접 구현 하게 되는 경험을 할수 있어 좋다. 어짜피 배우는 목적이 크기 떄문에 이점이 큰 장점이다. 최근 Repository 부분이 필요 하겠다 싶어서 Hibernate를 쓸까 했는데, 굳이 라는 생각에, Repository Interface 만 만들어 놓고 ArrayList 를 사용 해 구현해 두었다. 몇몇 점이 걸리긴 했지만, 간단히 빠르게 만들고 필요 하면 확장 하는 느낌이라 전체적으로 코드들이 성장 하고 있는 것 같다. 

다른 장점은 API 서버 개발시 실 코드가 많이 안들어가 비즈니스 로직에 더 집중할 수 있는 것 같다. 프레임워크 구조가 복잡하지 않아 필요한 부분은 직접 커스텀 할 수 있는 점도 장점이다. Json 맵핑 부분은 나중에 Router 구현체에 넣어 자동화 할 생각 이다. Router 부분만 테스트를 할 수 있는데 의존성이 하나도 없어 Unit 테스트 하기 좋다.

또 다른 장점은 서버의 경량이 테스트 속도에 빠르다. 심지어 모든걸 로드 하는 API 테스트인데도, 자주 돌려서며, 테스트 확인을 한다. Router 부분이 많아지고 로직이 복잡해지면 무거워지겠지....

해당 프레임워크가 kotlin 을 지원 하는데, 나중에 kotlin 으로 마이그레이션 해볼까 생각 중이다.



## 리펙토링

JAVA를 좋아하는 큰 이유가 있는데, OOP 에 대한 이해도를 높혀준 언어이기 때문이다. TDD 와 리펙토링을 하면 단일 함수가 클래스로 성장해 나가는 모습을 보고 않은 것을 느끼고, Interface 를 사용한 다양한 관계를 만들고 그 관계가 의미가 되는 점 등이 JAVA 를 좋아하게 만든 것 같다. 뭐 이런 것이 있는 언어는 많지만, 레퍼런스가 JAVA 만큼 만은 풍성하지는 않은 것 같다. 그래서 JAVA 코드를 리펙토링 하는 것은 나에게는 즐거운일이다. 게다가 테스트가 갖춰진 코드를 리펙토링하는 것은 정말 재밌다. 

코드를 짜다보면 단순한 1 ~ 3 줄이 클래스로 보이고 몇몇 함수들이 중복으로 쓰이고 그런 것들이 클래스로 보이기 시작하면 리펙토링을 하고 싶어진다. 또 intellij 는 리펙토링 자동화가 정말 잘되있다. 다만 내가 잘 못씀 ㅠㅠ

Repository 도 main 함수에서 List 를 사용해서 만든 부분이 Repository로 추상화 할 수 있을 것 같았고 그렇게 리펙토링을 해 Interface  를 만들고 구현체를 만드는 것이 코드가 성장한다는 느낌을 준다. 그래도 계속 코드를 가다듬는 작업을 많이 하는데, 업무에서는... 아직 미숙함이 큰것 같다.



